#!/usr/bin/env python3
"""Build importable GRN crop catalog seed files from OpenFarm's public crops.csv.

Source: https://raw.githubusercontent.com/openfarmcc/OpenFarm/mainline/lib/crops.csv
"""

from __future__ import annotations

import csv
import json
import re
import urllib.request
from pathlib import Path

SOURCE_URL = "https://raw.githubusercontent.com/openfarmcc/OpenFarm/mainline/lib/crops.csv"
ROOT = Path(__file__).resolve().parents[2]
OUT_DIR = ROOT / "data" / "catalog"
OUT_JSONL = OUT_DIR / "openfarm_crops_import.jsonl"
OUT_SQL = OUT_DIR / "openfarm_crops_seed.sql"
OUT_META = OUT_DIR / "openfarm_crops_source_notes.md"
MAX_RECORDS = 2000


def slugify(value: str) -> str:
    value = value.strip().lower()
    value = re.sub(r"\(.*?\)", "", value)
    value = re.sub(r"[^a-z0-9]+", "-", value)
    value = re.sub(r"-+", "-", value).strip("-")
    return value[:96]


def sql_quote(value: str | None) -> str:
    if value is None:
        return "NULL"
    return "'" + value.replace("'", "''") + "'"


def fetch_csv_lines() -> list[list[str]]:
    req = urllib.request.Request(SOURCE_URL, headers={"User-Agent": "GRN-Catalog-Builder/1.0"})
    with urllib.request.urlopen(req, timeout=60) as resp:
        body = resp.read().decode("utf-8", errors="replace")
    return list(csv.reader(body.splitlines()))


def normalize_rows(rows: list[list[str]]) -> list[dict]:
    dedupe: dict[str, dict] = {}

    for row in rows:
        if not row:
            continue
        scientific = (row[0] or "").strip()
        common = (row[1] if len(row) > 1 else "").strip()

        if not scientific or scientific.startswith("?"):
            continue

        # Keep the initial import practical for newbies: prefer entries with a usable common name
        # and a species-style scientific name.
        if not common:
            continue
        if " " not in scientific:
            continue

        slug_base = common or scientific
        slug = slugify(slug_base)
        if not slug:
            continue

        if slug in dedupe:
            continue

        dedupe[slug] = {
            "slug": slug,
            "common_name": common or scientific,
            "scientific_name": scientific,
            "category": None,
            "description": None,
            "source": "openfarmcc/openfarm",
            "source_id": scientific,
            "source_url": SOURCE_URL,
            "attribution": "OpenFarm community dataset (GitHub archive)",
        }

    records = sorted(dedupe.values(), key=lambda r: r["slug"])
    return records[:MAX_RECORDS]


def write_jsonl(records: list[dict]) -> None:
    with OUT_JSONL.open("w", encoding="utf-8") as f:
        for rec in records:
            f.write(json.dumps(rec, ensure_ascii=False) + "\n")


def write_sql(records: list[dict]) -> None:
    lines = [
        "-- Generated by scripts/catalog/build_openfarm_seed.py",
        f"-- Source: {SOURCE_URL}",
        "begin;",
    ]

    for r in records:
        lines.extend(
            [
                "insert into crops (slug, common_name, scientific_name, category, description)",
                "values ("
                + ", ".join(
                    [
                        sql_quote(r["slug"]),
                        sql_quote(r["common_name"]),
                        sql_quote(r["scientific_name"]),
                        sql_quote(r["category"]),
                        sql_quote(r["description"]),
                    ]
                )
                + ")",
                "on conflict (slug) do update set",
                "  common_name = excluded.common_name,",
                "  scientific_name = excluded.scientific_name,",
                "  category = excluded.category,",
                "  description = excluded.description,",
                "  updated_at = now();",
                "",
            ]
        )

    lines.append("commit;")
    OUT_SQL.write_text("\n".join(lines), encoding="utf-8")


def write_meta(records: list[dict]) -> None:
    OUT_META.write_text(
        "\n".join(
            [
                "# OpenFarm Crop Source Notes",
                "",
                f"- Source URL: `{SOURCE_URL}`",
                "- Upstream project: https://github.com/openfarmcc/OpenFarm",
                "- Retrieval mode: public GitHub raw file download",
                f"- Records generated: **{len(records)}**",
                "",
                "## Attribution",
                "Use attribution text in-product/docs:",
                "",
                "`Plant names sourced from the OpenFarm community dataset (openfarmcc/OpenFarm archive).`",
                "",
                "## Licensing / usage note",
                "This file should be treated as source research output; confirm data licensing expectations before public redistribution beyond GRN app usage.",
            ]
        ),
        encoding="utf-8",
    )


def main() -> None:
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    rows = fetch_csv_lines()
    records = normalize_rows(rows)
    write_jsonl(records)
    write_sql(records)
    write_meta(records)
    print(f"Generated {len(records)} records")
    print(OUT_JSONL)
    print(OUT_SQL)


if __name__ == "__main__":
    main()
